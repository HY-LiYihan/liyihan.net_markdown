#!/usr/bin/env python3
import os
import yaml
import frontmatter
from pathlib import Path

GITHUB_REPO_URL = "https://github.com/HY-LiYihan/liyihan.net_markdown/blob/main/"
SITE_URL = "https://liyihan.net"
VERSION_FILE = 'VERSION'
VERSIONS_DIR = 'versions'

CATEGORIES = {
    'Linux': 'Linux',
    'å·¥å…·': 'å·¥å…·',
    'å¼€å‘': 'å¼€å‘'
}

EMOJI_MAP = {
    'Linux': 'ğŸ§',
    'å·¥å…·': 'ğŸ› ï¸',
    'å¼€å‘': 'ğŸ’»'
}

def parse_markdown_file(filepath):
    try:
        post = frontmatter.load(filepath)
        return {
            'title': post.get('title', Path(filepath).stem),
            'path': filepath,
            'categories': post.get('categories', []),
            'tags': post.get('tags', [])
        }
    except Exception as e:
        print(f"Error parsing {filepath}: {e}")
        return None

def scan_directory(category_name, dir_path):
    files = []
    if not os.path.exists(dir_path):
        return files

    for root, dirs, filenames in os.walk(dir_path):
        for filename in filenames:
            if filename.endswith('.md'):
                filepath = os.path.join(root, filename)
                post_info = parse_markdown_file(filepath)
                if post_info:
                    # è®¡ç®—ç›¸å¯¹äºé¡¹ç›®æ ¹ç›®å½•çš„è·¯å¾„
                    rel_path = os.path.relpath(filepath, '.')
                    post_info['path'] = rel_path
                    files.append(post_info)

    return files

def generate_readme():
    readme_content = "# LiYiHan Knowledge Base\n\n"
    readme_content += "æœ¬çŸ¥è¯†åº“æ±‡é›†ä¸ªäººæŠ€æœ¯ç¬”è®°ä¸é€ŸæŸ¥æ‰‹å†Œï¼Œè®¿é—®å®Œæ•´ç‰ˆè¯·è‡³ [liyihan.net](https://liyihan.net)\n\n"

    # ç¡®å®šè¦æ‰«æçš„ç›®å½•
    if os.path.exists(VERSION_FILE):
        current_version = open(VERSION_FILE, 'r').read().strip()
        version_info_path = os.path.join(VERSIONS_DIR, current_version, 'version_info.yaml')

        # æ·»åŠ ç‰ˆæœ¬ç®¡ç†éƒ¨åˆ†
        readme_content += "## ğŸ“¦ ç‰ˆæœ¬ç®¡ç†\n\n"
        readme_content += f"**å½“å‰ç‰ˆæœ¬**: `{current_version}`"

        if os.path.exists(version_info_path):
            with open(version_info_path, 'r', encoding='utf-8') as f:
                version_info = yaml.safe_load(f)
                created_at = version_info.get('created_at', '')[:10]
                readme_content += f" ({created_at})\n\n"
                readme_content += f"- æ€»æ–‡ç« æ•°: {version_info.get('total_articles', 0)} ç¯‡\n"
                if version_info.get('previous_version'):
                    previous = version_info['previous_version']
                    readme_content += f"- ä¸Šä¸€ä¸ªç‰ˆæœ¬: [`{previous}`]({GITHUB_REPO_URL}versions/{previous}/)\n"
        else:
            readme_content += "\n"

        readme_content += f"- [æŸ¥çœ‹æ‰€æœ‰ç‰ˆæœ¬]({GITHUB_REPO_URL}versions/)\n\n"
        readme_content += "---\n\n"

        # æ‰«æå½“å‰ç‰ˆæœ¬ç›®å½•
        base_dir = os.path.join(VERSIONS_DIR, current_version)
    else:
        base_dir = '.'

    # æŒ‰åˆ†ç±»å±•ç¤º
    for category_name, dir_name in CATEGORIES.items():
        category_path = os.path.join(base_dir, dir_name)
        files = scan_directory(category_name, category_path)

        emoji = EMOJI_MAP.get(category_name, '')
        readme_content += f"## {emoji} {category_name}\n"

        if files:
            for file_info in files:
                rel_path = file_info['path'].replace('\\', '/')
                full_url = GITHUB_REPO_URL + rel_path
                readme_content += f"- [{file_info['title']}]({full_url})\n"
        else:
            readme_content += "*æš‚æ— å†…å®¹*\n"

        readme_content += "\n"

    readme_content += "---\n\n*Auto-generated by scripts/generate_readme.py*"

    return readme_content

def main():
    readme_content = generate_readme()

    with open('README.md', 'w', encoding='utf-8') as f:
        f.write(readme_content)

    print("[OK] README.md generated")

if __name__ == '__main__':
    main()
